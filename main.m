(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
<<xAct`SymSpin`


(* ::Input::Initialization:: *)
SetOptions[DefFundSpinOperators,ShowValenceInfo->False]; 


(* ::Input::Initialization:: *)
$DefInfoQ=False;


(* ::Input::Initialization:: *)
$PrePrint=ScreenDollarIndices;


(* ::Input::Initialization:: *)
(* Penrose& Rindler conventions. *)
{$PsiSign=1,$PhiSign=1,$LambdaSign=1,$ChiSign=1,$RicciSign=1,$RiemannSign=-1};


(* ::Input::Initialization:: *)
(* Declare 4-manifold. *)
DefManifold[M4,4,{a,b,c,d,f,h,l,m,p,q}]


(* ::Input::Initialization:: *)
(* Declare abstract Lorentzian metric. *)
DefMetric[{1,3,0},g[-a,-b],CD,PrintAs->"g",DefInfo->False]


(* ::Input::Initialization:: *)
SetOptions[DefFundSpinOperators,ShowValenceInfo->False];
SetOptions[DefAbstractIndex,PrintAs->PrimeDagger];
SetOptions[DefSpinor,PrintDaggerAs->AddBar];
Off[ValidateSymbol::"capital"]

(* Declare a spin structure on the 4-manifold *)
DefSpinStructure[g,Spin,{A,B,C,D,F,H,L,M,P,Q,R,S},\[Epsilon],\[Sigma],CDe,{";","\[EmptyDownTriangle]"},SpinorPrefix->SP,SpinorMark->"S"]


(* ::Input::Initialization:: *)
(* Set $DefaultSpinBundle so some commands can be called without specifying the spin bundle every time. *)
InitSymSpin[\[Sigma]];


(* ::Input::Initialization:: *)
(* Set some DisplayForm options. *)
{PrintAs[PsiCDe]^="\[CapitalPsi]",PrintAs[PhiCDe]^="\[CapitalPhi]",PrintAs[LambdaCDe]^="\[CapitalLambda]"};
xAct`SpinFrames`Private`PrintDaggerAsBar/@{\[Epsilon],PsiCDe};


(* ::Input::Initialization:: *)
(* Set some TexPrint options. *)
Tex[\[Epsilon]\[Dagger]]^="\\conjugate\\epsilon";
Tex[PsiCDe\[Dagger]]^="\\conjugate\\Psi";
SetOptions[TexBreak,TexBreakString->" \\nonumber \\\\ \n &"];


(* ::Input::Initialization:: *)
$CVVerbose=False;


(* ::Input::Initialization:: *)
(* Declare fundamental derivatives. *)
DefFundSpinOperators@CDe;


(* ::Input::Initialization:: *)
TensorMatrix::usage="TensorMatrix[mat] represents mat as a matrix of tensors.";


(* ::Input::Initialization:: *)
MatrixOp::usage="MatrixOp[mat] represents mat as a matrix op operators.";


(* ::Input::Initialization:: *)
MakeBoxes[TensorMatrix[matrix_List],StandardForm]:=xAct`xTensor`Private`interpretbox[TensorMatrix[matrix],RowBox[{"(",Map[PrintAs,GridBox[matrix],{3}],")"}]]


(* ::Input::Initialization:: *)
Tex[TensorMatrix[matrix_List]]:=StringJoin["{",TexBMatrix[matrix],"}"];


(* ::Input::Initialization:: *)
SetDelayed[MatrixOpQ[_],False]


(* ::Input::Initialization:: *)
SetNumberOfArguments[MatrixOpQ,1]


(* ::Input::Initialization:: *)
Protect[MatrixOpQ];


(* ::Input::Initialization:: *)
SetAttributes[HeldMatrixOpQ,HoldAllComplete];
HeldMatrixOpQ[expr_]:=MatrixOpQ[Unevaluated[expr]];


(* ::Input::Initialization:: *)
TexNoparOp[expr_TensorPlus] := Tex[expr];
TexNoparOp[expr_] := xAct`SymManipulator`Private`TexFundOp[expr];


(* ::Input::Initialization:: *)
Tex[MatrixOp[opmatrix_List]] := TexBMatrix[opmatrix,TexNoparOp]


(* ::Input::Initialization:: *)
Tex[MatrixOp[opmatrix_List][TensorMatrix[tmatrix_List]]]:=StringJoin["{",TexNoparOp[MatrixOp[opmatrix]],"}{",TexBMatrix[tmatrix],"}"]


(* ::Input::Initialization:: *)
MakeBoxes[MatrixOp[matrix_List],StandardForm]:=xAct`xTensor`Private`interpretbox[MatrixOp[matrix],RowBox[{"(",Map[xAct`SymSpin`Private`PrintAsNoPar,GridBox[matrix],{3}],")"}]]


(* ::Input::Initialization:: *)
xTensorFormStart[MatrixOp]:=(
MakeBoxes[ih_?HeldMatrixOpQ[expr_],StandardForm]:=xAct`xTensor`Private`interpretbox[ih[expr],RowBox[{PrintAs[Unevaluated[ih]],"[",MakeBoxes[expr,StandardForm],"]"}]];
MakeBoxes[ih_?HeldMatrixOpQ,StandardForm]:=xAct`xTensor`Private`interpretbox[ih,RowBox[{PrintAs[Unevaluated[ih]]}]]);
xTensorFormStop[MatrixOp]:=(MakeBoxes[ih_?HeldMatrixOpQ[expr_],StandardForm]=.;MakeBoxes[ih_?HeldMatrixOpQ,StandardForm]=.);
xTensorFormStart[MatrixOp]


(* ::Input::Initialization:: *)
SpinorToDummySpinor[TT_?(SymmetricSpinorOfArbitraryValenceQ[])]:=TT->SymSpinor[NumOfUnprimedSlots[$DefaultSpinBundle][TT],NumOfPrimedSlots[$DefaultSpinBundle][TT],xAct`SymSpin`Private`DummySymbol,$DefaultSpinBundle]


(* ::Input::Initialization:: *)
MatrixOpRule=MatrixOp[opmatrix_List][TensorMatrix[tmatrix_List]]:>Module[{},TensorMatrix@Inner[#1/.Reverse[SpinorToDummySpinor[#2]]&,opmatrix,tmatrix,TensorPlus]];


(* ::Input::Initialization:: *)
TensorMatrixToList=TensorMatrix[tmatrix_List]:>Map[GiveIndicesToTensor,tmatrix,{2}];


(* ::Input::Initialization:: *)
TensorMatrixEqToList[expr_Equal]:=Expand[Flatten[Thread/@Thread[expr/.TensorMatrixToList]]];


(* ::Input::Initialization:: *)
EqListToTensorMatrixEq[teqlist_List,vars_List]:=TensorMatrix[Transpose[{(First/@teqlist)}]]==MatrixOp[Outer[(TensorMinus[#1[[2]],(#1[[2]]/.TensorToZeroRule[#2])]/.SpinorToDummySpinor[#2])&,teqlist,vars]]@TensorMatrix[Transpose[{vars}]]


(* ::Input::Initialization:: *)
ListToTensorMatrix[oplist_List,vars_List]:=MatrixOp[Outer[(TensorMinus[#1,(#1/.TensorToZeroRule[#2])]/.SpinorToDummySpinor[#2])&,oplist,vars]]@TensorMatrix[Transpose[{vars}]]


(* ::Input::Initialization:: *)
xTensorQ[LieW[\[Xi]_?xTensorQ,w_,LL_?xTensorQ]]^=True;


(* ::Input::Initialization:: *)
SlotsOfTensor[LieW[\[Xi]_?xTensorQ,w_,LL_?xTensorQ]]^:=SlotsOfTensor[LL];


(* ::Input::Initialization:: *)
SymmetryGroupOfTensor[LieW[\[Xi]_?xTensorQ,w_,LL_?xTensorQ]]^:=SymmetryGroupOfTensor[LL]


(* ::Input::Initialization:: *)
PrintAs[LieW[\[Xi]_?xTensorQ,0,LL_?xTensorQ]]^:=RowBox[{SubscriptBox["\[ScriptCapitalL]",PrintAs[\[Xi]]],PrintAs[LL]}];


(* ::Input::Initialization:: *)
PrintAs[LieW[\[Xi]_?xTensorQ,w_,LL_?xTensorQ]]^:=RowBox[{SubscriptBox["\!\(\*OverscriptBox[\(\[ScriptCapitalL]\), \(^\)]\)",RowBox[{PrintAs[\[Xi]],ToBoxes[w,StandardForm]}]],PrintAs[LL]}];


(* ::Input::Initialization:: *)
LieW[\[Xi]_?xTensorQ,w_,ZeroTensor[slotlist_]]:=ZeroTensor[slotlist];
LieW[ZeroTensor[slotlist_],w_,expr_]:=ZeroTensor[SlotsOfTensor@expr];


(* ::Input::Initialization:: *)
LieW[\[Xi]_?xTensorQ,w_,expr_TensorPlus]:=LieW[\[Xi],w,#]&/@expr


(* ::Input::Initialization:: *)
LieW[\[Xi]_?xTensorQ,w_,MultScal[c_?ConstantQ,TT_?xTensorQ]]:=MultScal[c,LieW[\[Xi],w,TT]]


(* ::Input::Initialization:: *)
LieWOpRule=LieW[\[Xi]_?xTensorQ,w_,LL_?xTensorQ]:>With[{k=NumOfUnprimedSlots[Spin]@LL,l=NumOfPrimedSlots[Spin]@LL},
TensorPlus[SymMult[\[Xi],1,1]@TwistCDe[LL],If[l>0,MultScal[-l/(l+1),SymMult[\[Xi],1,0]@CurlCDe[LL]],ZeroTensor@SlotsOfTensor@LL],If[k>0,MultScal[-k/(k+1),SymMult[\[Xi],0,1]@CurlDgCDe[LL]],ZeroTensor@SlotsOfTensor@LL],If[And[k>0,l>0],MultScal[k*l/(k+1)/(l+1),SymMult[\[Xi],0,0]@DivCDe[LL]],ZeroTensor@SlotsOfTensor@LL],If[k>0,MultScal[-1/2*k,SymMult[CurlCDe[\[Xi]],1,0]@LL],ZeroTensor@SlotsOfTensor@LL],If[l>0,MultScal[-1/2*l,SymMult[CurlDgCDe[\[Xi]],0,1]@LL],ZeroTensor@SlotsOfTensor@LL],MultScal[(w-(k+l)/8),SymMult[DivCDe[\[Xi]],0,0]@LL]]];


(* ::Input::Initialization:: *)
xAct`SymManipulator`Private`TexFundOp[LieW[\[Xi]_?xTensorQ,0,LL_?xTensorQ]]:=StringJoin["\\mathcal{L}_{",Tex[\[Xi]],"}",xAct`SymManipulator`Private`TexFundOp[LL]];


(* ::Input::Initialization:: *)
xAct`SymManipulator`Private`TexFundOp[LieW[\[Xi]_?xTensorQ,w_,LL_?xTensorQ]]:=StringJoin["\\hat{\\mathcal{L}}_{",Tex[\[Xi]],"}",xAct`SymManipulator`Private`TexFundOp[LL]];


(* ::Input::Initialization:: *)
DefConstantSymbol[mass,PrintAs->"m"]


(* ::Input::Initialization:: *)
DefSpinor[phi[-A],M4,PrintAs->"\[Phi]"]
DefSpinor[chi[-A\[Dagger]],M4,PrintAs->"\[Chi]"]


(* ::Input::Initialization:: *)
DefSpinor[lambda[-A],M4,PrintAs->"\[Lambda]"]
DefSpinor[gamma[-A\[Dagger]],M4,PrintAs->"\[Gamma]"]


(* ::Input::Initialization:: *)
DefSpinor[K0Coeff[-A,-B],M4,PrintAs->"K0"]
DefSpinor[L0Coeff[-A,A\[Dagger]],M4,PrintAs->"L0"]
DefSpinor[M0Coeff[-A,A\[Dagger]],M4,PrintAs->"M0"]
DefSpinor[N0Coeff[A\[Dagger],B\[Dagger]],M4,PrintAs->"N0"]
DefSpinor[K1Coeff[-A,-B,-C,-A\[Dagger]],M4,Symmetric[{2,3}],PrintAs->"K1"]
DefSpinor[L1Coeff[-A,-B,-A\[Dagger],-B\[Dagger]],M4,Symmetric[{3,4}],PrintAs->"L1"]
DefSpinor[M1Coeff[-A,-B,-A\[Dagger],-B\[Dagger]],M4,Symmetric[{1,2}],PrintAs->"M1"]
DefSpinor[N1Coeff[-A,-A\[Dagger],-B\[Dagger],-C\[Dagger]],M4,Symmetric[{3,4}],PrintAs->"N1"]
DefSpinor[K2Coeff[-A,-B,-C,-D,-A\[Dagger],-B\[Dagger]],M4,JoinSGS[Symmetric[{2,3,4}],Symmetric[{5,6}]],PrintAs->"K2"]
DefSpinor[L2Coeff[-A,-B,-C,-A\[Dagger],-B\[Dagger],-C\[Dagger]],M4,JoinSGS[Symmetric[{2,3}],Symmetric[{4,5,6}]],PrintAs->"L2"]
DefSpinor[M2Coeff[-A,-B,-C,-A\[Dagger],-B\[Dagger],-C\[Dagger]],M4,JoinSGS[Symmetric[{1,2,3}],Symmetric[{5,6}]],PrintAs->"M2"]
DefSpinor[N2Coeff[-A,-B,-A\[Dagger],-B\[Dagger],-C\[Dagger],-D\[Dagger]],M4,JoinSGS[Symmetric[{1,2}],Symmetric[{4,5,6}]],PrintAs->"N2"]



